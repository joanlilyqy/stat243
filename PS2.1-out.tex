\documentclass{article}\usepackage{graphicx, color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\definecolor{fgcolor}{rgb}{0.2, 0.2, 0.2}
\newcommand{\hlnumber}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlfunctioncall}[1]{\textcolor[rgb]{0.501960784313725,0,0.329411764705882}{\textbf{#1}}}%
\newcommand{\hlstring}[1]{\textcolor[rgb]{0.6,0.6,1}{#1}}%
\newcommand{\hlkeyword}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlargument}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlcomment}[1]{\textcolor[rgb]{0.180392156862745,0.6,0.341176470588235}{#1}}%
\newcommand{\hlroxygencomment}[1]{\textcolor[rgb]{0.43921568627451,0.47843137254902,0.701960784313725}{#1}}%
\newcommand{\hlformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlassignement}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlpackage}[1]{\textcolor[rgb]{0.588235294117647,0.709803921568627,0.145098039215686}{#1}}%
\newcommand{\hlslot}[1]{\textit{#1}}%
\newcommand{\hlsymbol}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlprompt}[1]{\textcolor[rgb]{0.2,0.2,0.2}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\today}
\chead{Ying Qiao SID:21412301}
\rhead{Stat243 Fa12: Problem Set 2}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{listings}

%% for inline R code: if the inline code is not correctly parsed, you will see a message
\newcommand{\rinline}[1]{SOMETHING WORNG WITH knitr}




\begin{document}


\section*{Problem 1}

To have a function that lists the objects in the workspace in a nicely formatted manner, serveral auxiliary 
printing function (\textit{printObj}, \textit{printUnit}) is created first for cleaner coding. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{## Aux Printing Fun: Define printing control global parameter}
wid = 20  \hlcomment{# object name priting width}
digit = 10  \hlcomment{# byte size printing digits}
\hlcomment{## Print out file size according to auto-match units}
printUnit <- \hlfunctioncall{function}(obj) \{
    units = \hlfunctioncall{c}(\hlstring{""}, \hlstring{"k"}, \hlstring{"M"}, \hlstring{"G"})
    i = 1
    \hlfunctioncall{while} (obj >= 1024) \{
        obj = obj/1024
        i = i + 1
    \}  \hlcomment{# get proper units}
    \hlfunctioncall{if} (i == 1) \{
        \hlfunctioncall{cat}(\hlfunctioncall{format}(obj, width = digit, justify = \hlstring{"right"}), \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \} else \{
        \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlfunctioncall{as.integer}(obj), width = digit - 1, justify = \hlstring{"right"}), units[i], 
            \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \}
\}
\hlcomment{## Print out the object list in a nicely formatted way}
printObj <- \hlfunctioncall{function}(objList, objName, pretty) \{
    \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlstring{"object"}, width = wid), \hlfunctioncall{format}(\hlstring{"bytes"}, width = digit, justify = \hlstring{"right"}), 
        \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \hlfunctioncall{if} (pretty == FALSE) \{
        \hlcomment{# pretty==TRUE: it will call the printUnit to print out proper units for sizes}
        t <- \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(objList), \hlfunctioncall{function}(i) \{
            \hlfunctioncall{cat}(\hlfunctioncall{format}(objName[i], width = wid), \hlfunctioncall{format}(objList[i], width = digit, 
                justify = \hlstring{"right"}), \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
        \})
    \} else \{
        \hlcomment{# default:      it will just print out number of bytes}
        t <- \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(objList), \hlfunctioncall{function}(i) \{
            \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlfunctioncall{names}(objList)[i], width = wid))
            \hlfunctioncall{printUnit}(objList[i])
        \})
    \}
\}
\end{alltt}
\end{kframe}
\end{knitrout}


The main function will list objects ordered by size from largest to smallest; it allows the user to 
either specify how many objects to list or to specify that objects larger than a certain size 
to be listed. The argument \textit{pretty}, when TRUE, results in the size of the objects being printed 
with the units tailored by function \textit{printUnit}.
By default, \textit{lsObj<-function(numls=100, sizeB=0, pretty=FALSE)} 
will give sensible results.	
Also, the main function shown below is already written to be able to print out only
objects in the frame of the function call when called from within another function.

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
lsObj <- \hlfunctioncall{function}(numls = 100, sizeB = 0, pretty = FALSE) \{
    listLs <- \hlfunctioncall{ls}(envir = \hlfunctioncall{parent.frame}())  \hlcomment{# object list}
    sizeLs <- \hlfunctioncall{sapply}(listLs, \hlfunctioncall{function}(x) \{
        \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = \hlfunctioncall{parent.frame}(n = 4)))
    \})
    \hlcomment{# get all object sizes from within the called frame;}
    \hlcomment{# n=4:FUN->sapply->lsObj->\hlfunctioncall{call}(lsObj)}
    tmpEnv <- NULL
    nameEnv <- NULL  \hlcomment{# store object sizes and names within a certain user-defined ENV}
    tmpFun <- NULL
    nameFun <- NULL  \hlcomment{# store object sizes and names within a function closure}
    \hlfunctioncall{for} (item in listLs) \{
        \hlcomment{# elborate objects to find hidden ones}
        objitem <- \hlfunctioncall{get}(item, envir = \hlfunctioncall{parent.frame}())
        \hlfunctioncall{if} (\hlfunctioncall{is.environment}(objitem)) \{
            \hlcomment{# get sizes and store names with ENV prefix}
            tt <- \hlfunctioncall{sapply}(\hlfunctioncall{ls}(envir = objitem), \hlfunctioncall{function}(x) \{
                \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = objitem))
            \})
            tmpEnv <- \hlfunctioncall{c}(tmpEnv, tt)
            nameEnv <- \hlfunctioncall{c}(nameEnv, \hlfunctioncall{paste}(item, \hlstring{"$"}, \hlfunctioncall{ls}(envir = objitem), sep = \hlstring{""}))
        \}
        \hlfunctioncall{if} (\hlfunctioncall{is.function}(objitem) && \hlfunctioncall{identical}(\hlfunctioncall{environment}(objitem), \hlfunctioncall{parent.frame}()) == 
            FALSE) \{
            \hlcomment{# get sizes and store names with FUN prefix}
            tt <- \hlfunctioncall{sapply}(\hlfunctioncall{ls}(envir = \hlfunctioncall{environment}(objitem)), \hlfunctioncall{function}(x) \{
                \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = \hlfunctioncall{environment}(objitem)))
            \})
            tmpFun <- \hlfunctioncall{c}(tmpFun, tt)
            nameFun <- \hlfunctioncall{c}(nameFun, \hlfunctioncall{paste}(item, \hlstring{"$"}, \hlfunctioncall{ls}(envir = \hlfunctioncall{environment}(objitem)), 
                sep = \hlstring{""}))
        \}
    \}
    \hlfunctioncall{names}(tmpEnv) <- nameEnv
    \hlfunctioncall{names}(tmpFun) <- nameFun
    \hlfunctioncall{if} (\hlfunctioncall{length}(tmpEnv) > 0) 
        \{
            sizeLs <- \hlfunctioncall{c}(sizeLs, tmpEnv)
        \}  \hlcomment{#if there is use-defined ENV}
    \hlfunctioncall{if} (\hlfunctioncall{length}(tmpFun) > 0) 
        \{
            sizeLs <- \hlfunctioncall{c}(sizeLs, tmpFun)
        \}  \hlcomment{#if there is FUN closure}
    sizeLs <- sizeLs[sizeLs[] > sizeB]  \hlcomment{# find objects larger than \hlfunctioncall{sizeB}(bytes)}
    \hlfunctioncall{if} (numls > \hlfunctioncall{length}(sizeLs)) 
        \{
            numls = \hlfunctioncall{length}(sizeLs)
        \}  \hlcomment{#prune incorrect listing number}
    sizeLs <- \hlfunctioncall{sort}(sizeLs, decreasing = TRUE)[1:numls]  \hlcomment{# find the numls largest objects}
    nameLs <- \hlfunctioncall{names}(sizeLs)  \hlcomment{# get the name of vector}
    \hlfunctioncall{printObj}(sizeLs, nameLs, pretty)  \hlcomment{# print using the aux functions}
\}
\end{alltt}
\end{kframe}
\end{knitrout}


\newpage

The above main function has the capability to deal with user-created environments and objects within a closure.
It elborates the objects obtained from the \textit{ls()} function to see if there are user-defined ENV or FUN closure.
When detected, it then goes one frame down to the enclosing environment to get the hidden objects and assign names to
them with ENV/FUN prefix.


To create objects of various sizes for testing, I generated vectors of random normals of different lengths, 
along with serveral hidden ENV/FUN examples for testing.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{#### Generate objects test cases}
ob0 <- \hlfunctioncall{rnorm}(1)
ob1 <- \hlfunctioncall{rnorm}(10)
ob2 <- \hlfunctioncall{rnorm}(100)
ob3 <- \hlfunctioncall{rnorm}(1000)
ob4 <- \hlfunctioncall{rnorm}(10000)
ob5 <- \hlfunctioncall{rnorm}(1e+05)
ob6 <- \hlfunctioncall{rnorm}(1e+06)
ob7 <- \hlfunctioncall{rnorm}(1e+07)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## **********Test Case 1*************
## lsObj(5,128)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05
## ob4                      80040
## ob3                       8040

## **********Test Case 2*************
## lsObj(sizeB = 1024)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05
## ob4                      80040
## ob3                       8040

## **********Test Case 3*************
## lsObj(numls = 3)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05

## **********Test Case 4*************
## lsObj(pretty = TRUE)

## object                   bytes
## ob7                        76M
## ob6                         7M
## ob5                       781k
## ob4                        78k
## ob3                         7k
## ob2                        840
## ob1                        168
## ob0                         48
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
testFunc <- \hlfunctioncall{function} () \{
            	data <- \hlfunctioncall{rnorm}(10000);	data2 <- \hlfunctioncall{rnorm}(100000)
            	myFun <- \hlfunctioncall{function}(theta) \{ 
                       dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
	\hlfunctioncall{lsObj}()\}
testEx <- \hlfunctioncall{function} () \{
          	x <- \hlfunctioncall{rnorm}(100000);	data <- \hlfunctioncall{rnorm}(1000)
          	e <- \hlfunctioncall{new.env}(); e$a <- x \hlcomment{# an object hidden in an environment}
          	e2 <- \hlfunctioncall{new.env}(); e2$a2 <- x; e2$b2 <- 52
          	myFun <- \hlfunctioncall{function}(theta) \{ 
                     dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
          	myFun1 <- \hlfunctioncall{function}(theta) \{ 
                      dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
          	myFun2 <- \hlfunctioncall{with}(\hlfunctioncall{list}( data = x ), \hlcomment{# an object hidden in a closure}
                          \hlfunctioncall{function}(theta) \{ 
                          dist <- \hlfunctioncall{rdist}(data); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \} )
            myFun3 <- \hlfunctioncall{with}(\hlfunctioncall{list}( data2 = x ),
                          \hlfunctioncall{function}(theta2) \{ 
                          dist <- \hlfunctioncall{rdist}(data); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta2)); \} )
	\hlfunctioncall{lsObj}()\}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## **********Test Case 5*************
## lsObj() in testFunc()

## object                   bytes
## data2                    8e+05
## data                     80040
## myFun                     6072

## **********Test Case 6*************
## lsObj() in test testEx()

## object                   bytes
## x                        8e+05
## e$a                      8e+05
## e2$a2                    8e+05
## myFun2$data              8e+05
## myFun3$data2             8e+05
## data                      8040
## myFun                     6072
## myFun1                    6072
## myFun2                    6072
## myFun3                    6072
## e                           56
## e2                          56
## e2$b2                       48
\end{verbatim}
\end{kframe}
\end{knitrout}



\end{document}
