\documentclass{article}\usepackage{graphicx, color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\definecolor{fgcolor}{rgb}{0.2, 0.2, 0.2}
\newcommand{\hlnumber}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlfunctioncall}[1]{\textcolor[rgb]{0.501960784313725,0,0.329411764705882}{\textbf{#1}}}%
\newcommand{\hlstring}[1]{\textcolor[rgb]{0.6,0.6,1}{#1}}%
\newcommand{\hlkeyword}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlargument}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlcomment}[1]{\textcolor[rgb]{0.180392156862745,0.6,0.341176470588235}{#1}}%
\newcommand{\hlroxygencomment}[1]{\textcolor[rgb]{0.43921568627451,0.47843137254902,0.701960784313725}{#1}}%
\newcommand{\hlformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlassignement}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlpackage}[1]{\textcolor[rgb]{0.588235294117647,0.709803921568627,0.145098039215686}{#1}}%
\newcommand{\hlslot}[1]{\textit{#1}}%
\newcommand{\hlsymbol}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlprompt}[1]{\textcolor[rgb]{0.2,0.2,0.2}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\today}
\chead{Ying Qiao SID:21412301}
\rhead{Stat243 Fa12: Problem Set 2}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{listings}

%% for inline R code: if the inline code is not correctly parsed, you will see a message
\newcommand{\rinline}[1]{SOMETHING WORNG WITH knitr}




\begin{document}


\section*{Problem 1}

To have a function that lists the objects in the workspace in a nicely formatted manner, serveral auxiliary 
printing function (\textit{printObj}, \textit{printUnit}) is created first for cleaner coding. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{## Aux Printing Fun: Define printing control global parameter}
wid = 20  \hlcomment{# object name priting width}
digit = 10  \hlcomment{# byte size printing digits}
\hlcomment{## Print out file size according to auto-match units}
printUnit <- \hlfunctioncall{function}(obj) \{
    units = \hlfunctioncall{c}(\hlstring{""}, \hlstring{"k"}, \hlstring{"M"}, \hlstring{"G"})
    i = 1
    \hlfunctioncall{while} (obj >= 1024) \{
        obj = obj/1024
        i = i + 1
    \}  \hlcomment{# get proper units}
    \hlfunctioncall{if} (i == 1) \{
        \hlfunctioncall{cat}(\hlfunctioncall{format}(obj, width = digit, justify = \hlstring{"right"}), \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \} else \{
        \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlfunctioncall{as.integer}(obj), width = digit - 1, justify = \hlstring{"right"}), units[i], 
            \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \}
\}
\hlcomment{## Print out the object list in a nicely formatted way}
printObj <- \hlfunctioncall{function}(objList, objName, pretty) \{
    \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlstring{"object"}, width = wid), \hlfunctioncall{format}(\hlstring{"bytes"}, width = digit, justify = \hlstring{"right"}), 
        \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
    \hlfunctioncall{if} (pretty == FALSE) \{
        \hlcomment{# pretty==TRUE: it will call the printUnit to print out proper units for sizes}
        t <- \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(objList), \hlfunctioncall{function}(i) \{
            \hlfunctioncall{cat}(\hlfunctioncall{format}(objName[i], width = wid), \hlfunctioncall{format}(objList[i], width = digit, 
                justify = \hlstring{"right"}), \hlstring{"\textbackslash{}n"}, sep = \hlstring{""})
        \})
    \} else \{
        \hlcomment{# default:      it will just print out number of bytes}
        t <- \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(objList), \hlfunctioncall{function}(i) \{
            \hlfunctioncall{cat}(\hlfunctioncall{format}(\hlfunctioncall{names}(objList)[i], width = wid))
            \hlfunctioncall{printUnit}(objList[i])
        \})
    \}
\}
\end{alltt}
\end{kframe}
\end{knitrout}


The main function will list objects ordered by size from largest to smallest; it allows the user to 
either specify how many objects to list or to specify that objects larger than a certain size 
to be listed. The argument \textit{pretty}, when TRUE, results in the size of the objects being printed 
with the units tailored by function \textit{printUnit}.
By default, \textit{lsObj<-function(numls=100, sizeB=0, pretty=FALSE)} 
will give sensible results.	
Also, the main function shown below is already written to be able to print out only
objects in the frame of the function call when called from within another function.

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
lsObj <- \hlfunctioncall{function}(numls = 100, sizeB = 0, pretty = FALSE) \{
    listLs <- \hlfunctioncall{ls}(envir = \hlfunctioncall{parent.frame}())  \hlcomment{# object list}
    sizeLs <- \hlfunctioncall{sapply}(listLs, \hlfunctioncall{function}(x) \{
        \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = \hlfunctioncall{parent.frame}(n = 4)))
    \})
    \hlcomment{# get all object sizes from within the called frame;}
    \hlcomment{# n=4:FUN->sapply->lsObj->\hlfunctioncall{call}(lsObj)}
    tmpEnv <- NULL
    nameEnv <- NULL  \hlcomment{# store object sizes and names within a certain user-defined ENV}
    tmpFun <- NULL
    nameFun <- NULL  \hlcomment{# store object sizes and names within a function closure}
    \hlfunctioncall{for} (item in listLs) \{
        \hlcomment{# elborate objects to find hidden ones}
        objitem <- \hlfunctioncall{get}(item, envir = \hlfunctioncall{parent.frame}())
        \hlfunctioncall{if} (\hlfunctioncall{is.environment}(objitem)) \{
            \hlcomment{# get sizes and store names with ENV prefix}
            tt <- \hlfunctioncall{sapply}(\hlfunctioncall{ls}(envir = objitem), \hlfunctioncall{function}(x) \{
                \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = objitem))
            \})
            tmpEnv <- \hlfunctioncall{c}(tmpEnv, tt)
            nameEnv <- \hlfunctioncall{c}(nameEnv, \hlfunctioncall{paste}(item, \hlstring{"$"}, \hlfunctioncall{ls}(envir = objitem), sep = \hlstring{""}))
        \}
        \hlfunctioncall{if} (\hlfunctioncall{is.function}(objitem) && \hlfunctioncall{identical}(\hlfunctioncall{environment}(objitem), \hlfunctioncall{parent.frame}()) == 
            FALSE) \{
            \hlcomment{# get sizes and store names with FUN prefix}
            tt <- \hlfunctioncall{sapply}(\hlfunctioncall{ls}(envir = \hlfunctioncall{environment}(objitem)), \hlfunctioncall{function}(x) \{
                \hlfunctioncall{object.size}(\hlfunctioncall{get}(x, envir = \hlfunctioncall{environment}(objitem)))
            \})
            tmpFun <- \hlfunctioncall{c}(tmpFun, tt)
            nameFun <- \hlfunctioncall{c}(nameFun, \hlfunctioncall{paste}(item, \hlstring{"$"}, \hlfunctioncall{ls}(envir = \hlfunctioncall{environment}(objitem)), 
                sep = \hlstring{""}))
        \}
    \}
    \hlfunctioncall{names}(tmpEnv) <- nameEnv
    \hlfunctioncall{names}(tmpFun) <- nameFun
    \hlfunctioncall{if} (\hlfunctioncall{length}(tmpEnv) > 0) 
        \{
            sizeLs <- \hlfunctioncall{c}(sizeLs, tmpEnv)
        \}  \hlcomment{#if there is use-defined ENV}
    \hlfunctioncall{if} (\hlfunctioncall{length}(tmpFun) > 0) 
        \{
            sizeLs <- \hlfunctioncall{c}(sizeLs, tmpFun)
        \}  \hlcomment{#if there is FUN closure}
    sizeLs <- sizeLs[sizeLs[] > sizeB]  \hlcomment{# find objects larger than \hlfunctioncall{sizeB}(bytes)}
    \hlfunctioncall{if} (numls > \hlfunctioncall{length}(sizeLs)) 
        \{
            numls = \hlfunctioncall{length}(sizeLs)
        \}  \hlcomment{#prune incorrect listing number}
    sizeLs <- \hlfunctioncall{sort}(sizeLs, decreasing = TRUE)[1:numls]  \hlcomment{# find the numls largest objects}
    nameLs <- \hlfunctioncall{names}(sizeLs)  \hlcomment{# get the name of vector}
    \hlfunctioncall{printObj}(sizeLs, nameLs, pretty)  \hlcomment{# print using the aux functions}
\}
\end{alltt}
\end{kframe}
\end{knitrout}


\newpage

The above main function has the capability to deal with user-created environments and objects within a closure.
It elborates the objects obtained from the \textit{ls()} function to see if there are user-defined ENV or FUN closure.
When detected, it then goes one frame down to the enclosing environment to get the hidden objects and assign names to
them with ENV/FUN prefix.


To create objects of various sizes for testing, I generated vectors of random normals of different lengths, 
along with serveral hidden ENV/FUN examples for testing.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{#### Generate objects test cases}
ob0 <- \hlfunctioncall{rnorm}(1)
ob1 <- \hlfunctioncall{rnorm}(10)
ob2 <- \hlfunctioncall{rnorm}(100)
ob3 <- \hlfunctioncall{rnorm}(1000)
ob4 <- \hlfunctioncall{rnorm}(10000)
ob5 <- \hlfunctioncall{rnorm}(1e+05)
ob6 <- \hlfunctioncall{rnorm}(1e+06)
ob7 <- \hlfunctioncall{rnorm}(1e+07)
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## **********Test Case 1*************
## lsObj(5,128)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05
## ob4                      80040
## ob3                       8040

## **********Test Case 2*************
## lsObj(sizeB = 1024)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05
## ob4                      80040
## ob3                       8040

## **********Test Case 3*************
## lsObj(numls = 3)

## object                   bytes
## ob7                      8e+07
## ob6                      8e+06
## ob5                      8e+05

## **********Test Case 4*************
## lsObj(pretty = TRUE)

## object                   bytes
## ob7                        76M
## ob6                         7M
## ob5                       781k
## ob4                        78k
## ob3                         7k
## ob2                        840
## ob1                        168
## ob0                         48
\end{verbatim}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
testFunc <- \hlfunctioncall{function} () \{
            	data <- \hlfunctioncall{rnorm}(10000);	data2 <- \hlfunctioncall{rnorm}(100000)
            	myFun <- \hlfunctioncall{function}(theta) \{ 
                       dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
	\hlfunctioncall{lsObj}()\}
testEx <- \hlfunctioncall{function} () \{
          	x <- \hlfunctioncall{rnorm}(100000);	data <- \hlfunctioncall{rnorm}(1000)
          	e <- \hlfunctioncall{new.env}(); e$a <- x \hlcomment{# an object hidden in an environment}
          	e2 <- \hlfunctioncall{new.env}(); e2$a2 <- x; e2$b2 <- 52
          	myFun <- \hlfunctioncall{function}(theta) \{ 
                     dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
          	myFun1 <- \hlfunctioncall{function}(theta) \{ 
                      dist <- \hlfunctioncall{rnorm}(theta); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \}
          	myFun2 <- \hlfunctioncall{with}(\hlfunctioncall{list}( data = x ), \hlcomment{# an object hidden in a closure}
                          \hlfunctioncall{function}(theta) \{ 
                          dist <- \hlfunctioncall{rdist}(data); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta)); \} )
            myFun3 <- \hlfunctioncall{with}(\hlfunctioncall{list}( data2 = x ),
                          \hlfunctioncall{function}(theta2) \{ 
                          dist <- \hlfunctioncall{rdist}(data); \hlfunctioncall{return}(\hlfunctioncall{exp}(dist / theta2)); \} )
	\hlfunctioncall{lsObj}()\}
\end{alltt}
\end{kframe}
\end{knitrout}


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## **********Test Case 5*************
## lsObj() in testFunc()

## object                   bytes
## data2                    8e+05
## data                     80040
## myFun                     6072

## **********Test Case 6*************
## lsObj() in test testEx()

## object                   bytes
## x                        8e+05
## e$a                      8e+05
## e2$a2                    8e+05
## myFun2$data              8e+05
## myFun3$data2             8e+05
## data                      8040
## myFun                     6072
## myFun1                    6072
## myFun2                    6072
## myFun3                    6072
## e                           56
## e2                          56
## e2$b2                       48
\end{verbatim}
\end{kframe}
\end{knitrout}



\newpage
\section*{Problem 2}

After reading in the character vector text from the online traffic logs \textit{IPs.RData}, the 
code below could extract out all the IP numbers. In the meanwhile, it can determine how many IP 
addresses are in each element of the vector with function \textit{getIPnum}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
patIP <- \hlstring{"((\textbackslash{}\textbackslash{}d\{1,3\}\textbackslash{}\textbackslash{}.)\{3\}\textbackslash{}\textbackslash{}d\{1,3\})"}  #Perl style pattern for IP
getIPnum <- \hlfunctioncall{function}(t) \{
    \hlfunctioncall{if} (\hlfunctioncall{length}(\hlfunctioncall{grep}(patIP, t, perl = TRUE)) == 0) \{
        \hlfunctioncall{return}(0)
    \} else \{
        \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patIP, t, perl = TRUE)[[1]]))
    \}
\}  \hlcomment{# get number of IPs per text element}
getIPidx <- \hlfunctioncall{function}(t) \{
    \hlfunctioncall{return}(\hlfunctioncall{gregexpr}(patIP, t, perl = TRUE)[[1]])
\}  \hlcomment{# get index of IPs in text element}
ipNum <- \hlfunctioncall{sapply}(text, getIPnum, USE.NAMES = FALSE)  \hlcomment{# apply to the character vector}
ipIdx <- \hlfunctioncall{lapply}(text, getIPidx)  \hlcomment{# maintain list structure of index for each IP log}
ipStr <- \hlfunctioncall{regmatches}(text, ipIdx)
\hlcomment{# obtain IPs in list; multiple IPs per element stored in list items}
\end{alltt}
\end{kframe}
\end{knitrout}


The results of getting the number of IPs within one element of \textit{text} is one integer vector of 
the length \textit{length(text)}. All the extracted IPs are stored in the list \textit{ipStr}, 
with each element of a character vector in length \textit{ipNum[i]} of all the IPs from line \textit{text[i]}.
NA or no-IP results are treated as empty string.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{verbatim}
## The results of # of IPs in each text element (1:100):

##   [1] 1 0 1 0 2 1 0 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 0 0 0 0 1 0 1 1 1 0 0 1 1
##  [36] 2 1 1 1 1 1 0 0 0 1 2 0 0 1 0 1 1 1 1 1 1 1 1 1 1 2 0 1 0 0 1 0 0 0 0
##  [71] 0 2 1 1 0 1 1 1 0 0 1 0 1 1 0 1 2 1 1 2 1 0 1 0 1 1 1 1 1 1

## The first 10 lines of results:

## $`from munnari.OZ.AU (localhost [127.0.0.1]) by delta.cs.mu.OZ.AU
## (8.11.6/8.11.6) with ESMTP id g7MBQPW13260; Thu, 22 Aug 2002 18:26:25
## +0700 (ICT)`
## [1] "127.0.0.1"
## 
## $`from SpoolDir by EMS-SRV0 (Mercury 1.44); 22 Aug 02 14:50:31 +0000`
## character(0)
## 
## $`from ee.ed.ac.uk (sxs@dunblane [129.215.34.86]) by
## postbox.ee.ed.ac.uk (8.11.0/8.11.0) with ESMTP id g7ME1Li02942 for
## <forteana@yahoogroups.com>; Thu, 22 Aug 2002 15:01:21 +0100 (BST)`
## [1] "129.215.34.86"
## 
## $`from SpoolDir by EMS-SRV0 (Mercury 1.44); 22 Aug 02 15:01:34 +0000`
## character(0)
## 
## $`from [192.168.0.4] (chello062178142216.4.14.vie.surfer.at
## [62.178.142.216]) (authenticated bits=0) by mail.uptime.at (8.12.5/8.12.5)
## with ESMTP id g7MEI7Vp022036 for
## <spamassassin-devel@lists.sourceforge.net>; Thu, 22 Aug 2002 16:18:07
## +0200`
## [1] "192.168.0.4"    "62.178.142.216"
## 
## $`from m206-56.dsl.tsoft.com ([198.144.206.56] helo=perkel.com) by
## darwin.ctyme.com with asmtp (TLSv1:RC4-MD5:128) (Exim 3.35 #1) id
## 17htgP-0004te-00; Thu, 22 Aug 2002 08:15:37 -0700`
## [1] "198.144.206.56"
## 
## $`by jlooney.jinny.ie (Postfix, from userid 500) id 4F57189D;
## Thu, 22 Aug 2002 16:25:45 +0100 (IST)`
## character(0)
## 
## $`from dcu.ie (136.206.21.115) by hawk.dcu.ie (6.0.040) id
## 3D6203D3000136AD for iiu@taint.org; Thu, 22 Aug 2002 16:59:17 +0100`
## [1] "136.206.21.115"
## 
## $`from [66.218.67.174] by n19.grp.scd.yahoo.com with NNFMP;
## 22 Aug 2002 16:11:27 -0000`
## [1] "66.218.67.174"
## 
## $`from [66.218.67.189] by n10.grp.scd.yahoo.com with NNFMP;
## 22 Aug 2002 16:17:40 -0000`
## [1] "66.218.67.189"
\end{verbatim}
\end{kframe}
\end{knitrout}





\newpage

\section*{Problem 3}

The American Presidency Project at UCSB has the text from all of the State of the Union
speeches by US presidents, in which the president speaks to Congress to report on the 
situation in the country. We will use web scraping, text formatting and pattern matching 
to grab the data; and then do some statistical analysis on them.

\subsection*{(a)}

From the website, I download the \textit{index.html} file and use pattern matching
to pull out the individual URLs for each speech in order to download individual HTML files.
Files are converted to UNIX line-ending using \textit{fromdos}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
 \hlcomment{#### Download all html files}
 \hlfunctioncall{system}("wget -q -O \hlstring{'index_pres.html'} 
         \hlstring{'http://www.presidency.ucsb.edu/sou.php#axzz265cEKp1a'}")
 \hlfunctioncall{system}(\hlstring{"fromdos index_pres.html"})
 indexPres <- \hlfunctioncall{readLines}(\hlstring{'index_pres.html'},warn= FALSE)
 \hlcomment{# Get speech text source}
 patUrl1 <- 
 \hlstring{'\textbackslash{}\textbackslash{}s\{16\}<td width=\textbackslash{}\textbackslash{}\hlstring{"\textbackslash{}\textbackslash{}d\{2\}\textbackslash{}\textbackslash{}"} align=\textbackslash{}\textbackslash{}\hlstring{"center\textbackslash{}\textbackslash{}"} class=\textbackslash{}\textbackslash{}\hlstring{"doclist\textbackslash{}\textbackslash{}"}><a href=\textbackslash{}\textbackslash{}"'}
 indexPres <- indexPres[\hlfunctioncall{grep}(patUrl1,indexPres,perl= TRUE)]
 indexPres <- \hlfunctioncall{sapply}(indexPres, 
                     \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl1,\hlstring{""},x)\},USE.NAMES= FALSE)
 patUrl2 <- \hlstring{'\textbackslash{}\textbackslash{}">\textbackslash{}\textbackslash{}d\{4\}<\textbackslash{}\textbackslash{}/a>(\textbackslash{}\textbackslash{}*|)<\textbackslash{}\textbackslash{}/td>'}
 indexPres <- \hlfunctioncall{sapply}(indexPres, 
                     \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl2,\hlstring{""},x)\},USE.NAMES= FALSE)
 \hlcomment{# Get file id from the source url}
 patUrl3 <- 
 \hlstring{'http:\textbackslash{}\textbackslash{}/\textbackslash{}\textbackslash{}/www\textbackslash{}\textbackslash{}.presidency\textbackslash{}\textbackslash{}.ucsb\textbackslash{}\textbackslash{}.edu\textbackslash{}\textbackslash{}/ws\textbackslash{}\textbackslash{}/index\textbackslash{}\textbackslash{}.php\textbackslash{}\textbackslash{}?pid='}
 fileid <- \hlfunctioncall{sapply}(indexPres, 
                  \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl3,\hlstring{""},x)\},USE.NAMES= FALSE)
 \hlcomment{# Download all files and convert to unix}
 \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(fileid),
        \hlfunctioncall{function}(i)\{
        \hlfunctioncall{system}(\hlfunctioncall{paste}(\hlstring{"wget -q -O \hlstring{'"},fileid[i],\hlstring{".html'} \hlstring{'"},indexPres[i],\hlstring{"'}"},sep=\hlstring{""}));
        \hlfunctioncall{system}(\hlfunctioncall{paste}(\hlstring{"fromdos "},fileid[i],\hlstring{".html"},sep=\hlstring{""}))\})
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(b)}

For each speech, I use pattern matching to extract the body of the speech while retaining 
the name of the president and the year of the speech. The function is applied with vector
operations using \textit{sapply()}.

For the \textit{speechVec}, text pre-processing is done by 
\begin{enumerate}
\item
Replacing HTML line-end with UNIX ones 
\item
Removing all the HTML format operators
\item
Modifying all the HTML special characters to similar UTF-8 ones
\end{enumerate}

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Import all *.html lines}
ff <- \hlfunctioncall{sapply}(fileid, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{readLines}(\hlfunctioncall{paste}(x, \hlstring{".html"}, sep = \hlstring{""}), warn = FALSE)
\})
\hlcomment{# Get the president name}
patName <- \hlstring{"^<title>(.*?)<\textbackslash{}\textbackslash{}/title>"}
namePres <- ff[\hlfunctioncall{grep}(patName, ff, perl = TRUE)]
namePres <- \hlfunctioncall{sapply}(namePres, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patName, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
\}, USE.NAMES = FALSE)
namePres <- \hlfunctioncall{sapply}(namePres, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{":"}))[1])
\}, USE.NAMES = FALSE)
\hlcomment{# Get the talk date}
patDate <- \hlstring{"^.*<span class=\textbackslash{}\textbackslash{}\textbackslash{}"}docdate\textbackslash{}\textbackslash{}\textbackslash{}\hlstring{">(.*?)<\textbackslash{}\textbackslash{}/span>.*$"}
dateTalk <- ff[\hlfunctioncall{grep}(patDate, ff, perl = TRUE)]
dateTalk <- \hlfunctioncall{sapply}(dateTalk, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patDate, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
\}, USE.NAMES = FALSE)
dateTalk <- \hlfunctioncall{sapply}(dateTalk, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"^.*\textbackslash{}\textbackslash{}s"}, \hlstring{""}, x)
\}, USE.NAMES = FALSE)
\hlcomment{# Get the speech content text and prune for nice-format print}
patText <- \hlstring{"^.*<span class=\textbackslash{}\textbackslash{}\textbackslash{}"}displaytext\textbackslash{}\textbackslash{}\textbackslash{}\hlstring{">(.*?)<\textbackslash{}\textbackslash{}/span>.*$"}
speechVec <- ff[\hlfunctioncall{grep}(patText, ff, perl = TRUE)]
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patText, \hlstring{"\textbackslash{}\textbackslash{}1<p>"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# grab speech text}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"(<p.*?>|<\textbackslash{}\textbackslash{}/p>|<br>)"}, \hlstring{"\textbackslash{}n"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# for line ending}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"<.*?>"}, \hlstring{""}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# remove all html format}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{"&mdash;"}, \hlstring{" -- "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&nbsp;"}, \hlstring{"  "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&lsquo;"}, \hlstring{" ' "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&#8226;"}, \hlstring{" \textbackslash{}\textbackslash{}. "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&lt;"}, \hlstring{" < "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&deg;"}, \hlstring{" degree "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&pound;"}, \hlstring{" pound "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&fra.*?;"}, \hlstring{" 1/2 "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&O.*?;"}, \hlstring{"O"}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&e.*?;"}, \hlstring{"e"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# html special char}
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(c)}

Each speech is stored as a single character vector with all non-text stripped out. The encoding is converted from
WINDOWS-1251 to UTF-8.
Meanwhile, the information about the tags of "Laughter" and "Applause" and the number of times it was used
are kept as a record for each speech. The \textit{speechVec[i]} will be printed out in a nicely-formatted manner. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Remove audience response \hlfunctioncall{tags} (laughter & applause)}
patLau <- \hlstring{"\textbackslash{}\textbackslash{}[.*?(Laughter|laughter).*?\textbackslash{}\textbackslash{}]"}
patApp <- \hlstring{"\textbackslash{}\textbackslash{}[.*?(Applause|applause).*?\textbackslash{}\textbackslash{}]"}
getlauNum <- \hlfunctioncall{function}(x) \{
    \hlfunctioncall{if} (\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patLau, x, perl = TRUE)[[1]]) == 1 && \hlfunctioncall{gregexpr}(patLau, 
        x, perl = TRUE)[[1]] == -1) \{
        \hlfunctioncall{return}(0)
    \} else \{
        \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patLau, x, perl = TRUE)[[1]]))
    \}
\}  \hlcomment{# get the number of [laughter]}
getappNum <- \hlfunctioncall{function}(x) \{
    \hlfunctioncall{if} (\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patApp, x, perl = TRUE)[[1]]) == 1 && \hlfunctioncall{gregexpr}(patApp, 
        x, perl = TRUE)[[1]] == -1) \{
        \hlfunctioncall{return}(0)
    \} else \{
        \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patApp, x, perl = TRUE)[[1]]))
    \}
\}  \hlcomment{# get the number of [applause]}
lauNum <- \hlfunctioncall{sapply}(speechVec, getlauNum, USE.NAMES = FALSE)
appNum <- \hlfunctioncall{sapply}(speechVec, getappNum, USE.NAMES = FALSE)
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{iconv}(x, from = \hlstring{"WINDOWS-1251"}, to = \hlstring{"UTF-8"}, sub = \hlstring{" "})
\})
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(patLau, \hlstring{""}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(patApp, \hlstring{""}, x, perl = TRUE)
\})
\hlcomment{# remove all the non-verbal tags from the speech text}
\hlfunctioncall{names}(speechVec) <- NULL  \hlcomment{# clean the speechVec \hlfunctioncall{name} (otherwise, long and messy)}
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(d)}

The collection of speeches is stored in a clean fashion of list elements. The \textit{i}th entries of all the elements
in \textit{listSpeech} give information about the \textit{i}th speech. 
This is easy later for plotting variables changes over time.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
listSpeech <- \hlfunctioncall{list}()
listSpeech$id <- fileid
listSpeech$name <- namePres
listSpeech$date <- \hlfunctioncall{as.integer}(dateTalk)  \hlcomment{# conversion for plotting, sorting}
listSpeech$numLaughter <- lauNum
listSpeech$numApplause <- appNum
listSpeech$speech <- speechVec
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(e) (f)}

Words and sentences are extracted from each speech, and are stored as individual elements of a (rather long)
character vector. Counts are also done on both words and sentences.

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Speech analysis Grab words from the speech by replacing all non-word}
\hlcomment{# char with space and split}
getWords <- \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{"'"}, \hlstring{""}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(\hlstring{"\textbackslash{}\textbackslash{}W+"}, \hlstring{" "}, x, perl = TRUE)
    xs <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{"[ ]+"}, perl = TRUE))
    \hlfunctioncall{return}(xs[xs != \hlstring{""}])
\}
\hlcomment{# Grab sentences from the speech by spliting with ending chars like [.!?]}
getSents <- \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{" (Mr|Ms|Mrs|Dr|St|Sr|Jr)\textbackslash{}\textbackslash{}."}, \hlstring{"\textbackslash{}\textbackslash{}1"}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(\hlstring{"[\textbackslash{}\textbackslash{}.!\textbackslash{}\textbackslash{}?][ \textbackslash{}t]+"}, \hlstring{"\textbackslash{}n"}, x, perl = TRUE)
    xs <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{"\textbackslash{}n"}, perl = TRUE))
    \hlfunctioncall{return}(xs[xs != \hlstring{""}])
\}
listSpeech$wc <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{getWords}(x)))
\}, USE.NAMES = FALSE)  \hlcomment{# word count}
listSpeech$sc <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{getSents}(x)))
\}, USE.NAMES = FALSE)  \hlcomment{# sentence count}
listSpeech$wMean <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{mean}(\hlfunctioncall{nchar}(\hlfunctioncall{getWords}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{#avg word length}
listSpeech$wSD <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{sd}(\hlfunctioncall{nchar}(\hlfunctioncall{getWords}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# word length sd}
listSpeech$sMean <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{mean}(\hlfunctioncall{nchar}(\hlfunctioncall{getSents}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# avg sentence length}
listSpeech$sSD <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{sd}(\hlfunctioncall{nchar}(\hlfunctioncall{getSents}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# sentence length sd}
\end{alltt}
\end{kframe}
\end{knitrout}




\subsection*{(g) (h)}

We now start to extract some features of interest from the speeches to analyze how the speeches have
changed over time. The result of all this is a list with each element containing the information
about a speech: the speech as a single string, the vector of sentences, the vector of words
and the additional quantification of variables about the speech from (g) as well as
the non-verbal variables from (c).

\begin{enumerate}
\item
Length in words and sentences \textit{wc,sc}
\item
Average and SD of word and sentence lengths \textit{wMean,wSD,sMean,sSD}
\item
Number of quotations in each speech, mean length (in words), and SD of length (in words) of the 
quotations in each speech \textit{quoNum,quoMean,quoSD}
\item
The most common meaningful words, where non-meaningful words are pre-defined \textit{cmw}
\item
Counts of the following words or word stems: 
\scriptsize
\begin{description}
\item[I, we]
\item[America{,n}]
\item[democra{cy,tic}]
\item[republic]
\item[Democrat{,ic}]
\item[Republican]
\item[free{,dom}]
\item[war]
\item[God] -- not including God bless
\item[God Bless]
\item[{Jesus, Christ, Christian}]
\item[Woman] -- I think would be interesting
\end{description}
\end{enumerate}
\normalsize

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
tmpList <- \hlfunctioncall{matrix}(\hlfunctioncall{rep}(0, 226 * 15), nrow = 226, ncol = 15)
\hlcomment{## Speech list with element-wise analysis}
speechList <- \hlfunctioncall{list}()  \hlcomment{#empty list}
\hlcomment{# Get the non-meaningful words file}
\hlfunctioncall{system}(\hlstring{"wget -O \hlstring{'cmw.txt'} \hlstring{'http://www.textfixer.com/resources/common-english-words.txt'}"})
commonWords <- \hlfunctioncall{readLines}(\hlstring{"cmw.txt"}, warn = FALSE)
commonWords <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(commonWords, \hlstring{","}, perl = TRUE))
\hlcomment{# Element-wise analysis on each speech}
\hlfunctioncall{for} (i in 1:\hlfunctioncall{length}(fileid)) \{
    ss <- \hlfunctioncall{list}()  \hlcomment{#empty list element}
    \hlcomment{# Global attributes: from results \hlfunctioncall{before} (reproduce for better storage)}
    ss$id <- fileid[i]
    ss$name <- namePres[i]
    ss$date <- \hlfunctioncall{as.integer}(dateTalk[i])
    ss$numLaughter <- lauNum[i]
    ss$numApplause <- appNum[i]
    ss$speech <- speechVec[i]
    \hlcomment{# Indiv attributes: get from within each speech}
    talkWords <- \hlfunctioncall{getWords}(speechVec[i])
    talkSents <- \hlfunctioncall{getSents}(speechVec[i])
    ss$words <- talkWords  \hlcomment{# words vector}
    ss$sents <- talkSents  \hlcomment{# sentence vector}
    ss$wc <- \hlfunctioncall{length}(talkWords)  \hlcomment{# word count}
    ss$sc <- \hlfunctioncall{length}(talkSents)  \hlcomment{# sentence count}
    ss$wMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(talkWords))  \hlcomment{# avg word length}
    ss$wSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(talkWords))  \hlcomment{# word length sd}
    ss$sMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(talkSents))  \hlcomment{# avg sentence length}
    ss$sSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(talkSents))  \hlcomment{# sentence length sd; ss[14]}
    patQuo <- \hlstring{"\textbackslash{}"}(.*?)\textbackslash{}\hlstring{""}  # quotation pattern
    quo <- talkSents[\hlfunctioncall{grep}(patQuo, talkSents, perl = TRUE)]
    \hlfunctioncall{if} (\hlfunctioncall{length}(quo) != 0) \{
        \hlcomment{# get quotation attributes}
        quo <- \hlfunctioncall{sapply}(quo, \hlfunctioncall{function}(x) \{
            \hlfunctioncall{gsub}(patQuo, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
        \}, USE.NAMES = FALSE)
        ss$quoNum <- \hlfunctioncall{length}(quo)
        ss$quoMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(quo))
        ss$quoSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(quo))
    \} else \{
        ss$quoNum <- 0
        ss$quoMean <- 0
        ss$quoSD <- 0
    \}  \hlcomment{#ss[17]}
    
    cmw <- \hlfunctioncall{sort}(\hlfunctioncall{table}(talkWords), decreasing = TRUE)
    cmw <- cmw[\hlfunctioncall{which}(!(\hlfunctioncall{names}(cmw) %in% commonWords))]  \hlcomment{# get meaningful words}
    ss$cmw <- cmw[cmw >= 10]  \hlcomment{#arbitrary cut-off for display}
    ss$strIwe <- cmw[\hlfunctioncall{grep}(\hlstring{"^(I|[Ww]e)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'I|We'}; ss[19]
    ss$strAme <- cmw[\hlfunctioncall{grep}(\hlstring{"[Aa]\hlfunctioncall{merica}(|n)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'America'}
    ss$strDem <- cmw[\hlfunctioncall{grep}(\hlstring{"[Dd]\hlfunctioncall{emocra}(cy|tic)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'democratic'}
    ss$strRep <- cmw[\hlfunctioncall{grep}(\hlstring{"[Rr]\hlfunctioncall{epublic}(|n)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'republican'}
    ss$strFree <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ff]\hlfunctioncall{ree}(|dom)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'free'}
    ss$strWar <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ww]\hlfunctioncall{ar}(|s)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'war'}
    ss$strGod <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Gg]\hlfunctioncall{od}(|s)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'God'}
    ss$strChr <- cmw[\hlfunctioncall{grep}(\hlstring{"(Jesus|Christ|Christian)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'Chirst|Jesus'}
    ss$strWoman <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ww]om[ae]n$"}, \hlfunctioncall{names}(cmw))]  #Mystring \hlstring{'Woman'}; ss[27]
    ssGodBless <- talkSents[\hlfunctioncall{grep}(\hlstring{"[Gg]od [Bb]less"}, talkSents, perl = TRUE)]
    \hlfunctioncall{if} (\hlfunctioncall{length}(ssGodBless) != 0) \{
        \hlcomment{#string \hlstring{'God Bless'} from sentences}
        ss$strGodBless <- \hlfunctioncall{sapply}(ssGodBless, \hlfunctioncall{function}(x) \{
            \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(\hlstring{"[Gg]od [Bb]less"}, x, perl = TRUE)[[1]]))
        \}, USE.NAMES = FALSE)
    \} else \{
        ss$strGodBless <- 0
    \}
    \hlcomment{# add to speechList and listSpeech}
    speechList[[i]] <- ss
    tmpList[i, 1:3] <- \hlfunctioncall{unlist}(ss[15:17])  \hlcomment{#quo attr}
    tmpList[i, 4:13] <- \hlfunctioncall{sapply}(ss[19:28], sum)  \hlcomment{#cmw related attr}
\}
\hlcomment{# prepare for plotting, store as listSpeech elements}
listSpeech$quoNum <- tmpList[, 1]
listSpeech$quoMean <- tmpList[, 2]
listSpeech$quoSD <- tmpList[, 3]
listSpeech$strIwe <- tmpList[, 4]
listSpeech$strAme <- tmpList[, 5]
listSpeech$strDem <- tmpList[, 6]
listSpeech$strRep <- tmpList[, 7]
listSpeech$strFree <- tmpList[, 8]
listSpeech$strWar <- tmpList[, 9]
listSpeech$strGod <- tmpList[, 10]
listSpeech$strChr <- tmpList[, 11]
listSpeech$strWoman <- tmpList[, 12]
listSpeech$strGodBless <- tmpList[, 13]
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(i) (j)}

Some basic plots that show how the variables have changed over time are given below.





\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig} 

}


\end{knitrout}


We can see that the word counts of the speeches are higher prior to 1920s than the modern ages.
So does the avg word length and word length sd. The presidents nowadays seem to like brevity.


Similar plots for sentence counts and quotation counts are given below. The similar trends stand.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig21} 

}



{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig22} 

}


\end{knitrout}


In recent years, with full records of non-verbal attributes, we can see that [Laughter] and [Applause] counts
have some positive correlation. The speeches receive more responses from the audience around 2000 than other years.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig3} 

}


\end{knitrout}


And for presidents since Franklin Roosevelt in 1932, comparison between Republican presidents 
(Eisenhower, Nixon, Ford, Reagan, G. Bush, G.W. Bush) and Democratic presidents 
(Roosevelt, Truman, Kennedy, Johnson, Carter, Clinton, Obama) are also given below in the box-plot comparison.



\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-figRD} 

}


\end{knitrout}


\newpage
Some additional research with plotting that illustrates how the speeches have changed over time are shown below.
The different keywords have evolved over time, with peak in WAR during wartime and GOD-rich in recent years.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex1} 

}


\end{knitrout}


The comparison between Reps and Dems could be more interesting with the strings REPUBLICAN and DEMOCRATIC.
It seems that the Dems are more focused on their persuit while Reps are impartial to both words.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex2} 

}


\end{knitrout}



Some additional variables that quantify speech in interesting ways are produced. The number of digits shown within the
speech is a good indicator whether the president speaks more quantatively, or vice versa, more qualitatively.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex3} 

}


\end{knitrout}











\end{document}
