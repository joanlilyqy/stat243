\documentclass{article}\usepackage{graphicx, color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\definecolor{fgcolor}{rgb}{0.2, 0.2, 0.2}
\newcommand{\hlnumber}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlfunctioncall}[1]{\textcolor[rgb]{0.501960784313725,0,0.329411764705882}{\textbf{#1}}}%
\newcommand{\hlstring}[1]{\textcolor[rgb]{0.6,0.6,1}{#1}}%
\newcommand{\hlkeyword}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlargument}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlcomment}[1]{\textcolor[rgb]{0.180392156862745,0.6,0.341176470588235}{#1}}%
\newcommand{\hlroxygencomment}[1]{\textcolor[rgb]{0.43921568627451,0.47843137254902,0.701960784313725}{#1}}%
\newcommand{\hlformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hleqformalargs}[1]{\textcolor[rgb]{0.690196078431373,0.250980392156863,0.0196078431372549}{#1}}%
\newcommand{\hlassignement}[1]{\textcolor[rgb]{0,0,0}{\textbf{#1}}}%
\newcommand{\hlpackage}[1]{\textcolor[rgb]{0.588235294117647,0.709803921568627,0.145098039215686}{#1}}%
\newcommand{\hlslot}[1]{\textit{#1}}%
\newcommand{\hlsymbol}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlprompt}[1]{\textcolor[rgb]{0.2,0.2,0.2}{#1}}%

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\usepackage[margin=1in]{geometry}
\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{\today}
\chead{Ying Qiao SID:21412301}
\rhead{Stat243 Fa12: Problem Set 2}
\lfoot{}
\cfoot{\thepage}
\rfoot{}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{lmodern}
\usepackage[T1]{fontenc}
\usepackage{listings}

%% for inline R code: if the inline code is not correctly parsed, you will see a message
\newcommand{\rinline}[1]{SOMETHING WORNG WITH knitr}




\begin{document}


\section*{Problem 3}

The American Presidency Project at UCSB has the text from all of the State of the Union
speeches by US presidents, in which the president speaks to Congress to report on the 
situation in the country. We will use web scraping, text formatting and pattern matching 
to grab the data; and then do some statistical analysis on them.

\subsection*{(a)}

From the website, I download the \textit{index.html} file and use pattern matching
to pull out the individual URLs for each speech in order to download individual HTML files.
Files are converted to UNIX line-ending using \textit{fromdos}.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
 \hlcomment{#### Download all html files}
 \hlfunctioncall{system}("wget -q -O \hlstring{'index_pres.html'} 
         \hlstring{'http://www.presidency.ucsb.edu/sou.php#axzz265cEKp1a'}")
 \hlfunctioncall{system}(\hlstring{"fromdos index_pres.html"})
 indexPres <- \hlfunctioncall{readLines}(\hlstring{'index_pres.html'},warn= FALSE)
 \hlcomment{# Get speech text source}
 patUrl1 <- 
 \hlstring{'\textbackslash{}\textbackslash{}s\{16\}<td width=\textbackslash{}\textbackslash{}\hlstring{"\textbackslash{}\textbackslash{}d\{2\}\textbackslash{}\textbackslash{}"} align=\textbackslash{}\textbackslash{}\hlstring{"center\textbackslash{}\textbackslash{}"} class=\textbackslash{}\textbackslash{}\hlstring{"doclist\textbackslash{}\textbackslash{}"}><a href=\textbackslash{}\textbackslash{}"'}
 indexPres <- indexPres[\hlfunctioncall{grep}(patUrl1,indexPres,perl= TRUE)]
 indexPres <- \hlfunctioncall{sapply}(indexPres, 
                     \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl1,\hlstring{""},x)\},USE.NAMES= FALSE)
 patUrl2 <- \hlstring{'\textbackslash{}\textbackslash{}">\textbackslash{}\textbackslash{}d\{4\}<\textbackslash{}\textbackslash{}/a>(\textbackslash{}\textbackslash{}*|)<\textbackslash{}\textbackslash{}/td>'}
 indexPres <- \hlfunctioncall{sapply}(indexPres, 
                     \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl2,\hlstring{""},x)\},USE.NAMES= FALSE)
 \hlcomment{# Get file id from the source url}
 patUrl3 <- 
 \hlstring{'http:\textbackslash{}\textbackslash{}/\textbackslash{}\textbackslash{}/www\textbackslash{}\textbackslash{}.presidency\textbackslash{}\textbackslash{}.ucsb\textbackslash{}\textbackslash{}.edu\textbackslash{}\textbackslash{}/ws\textbackslash{}\textbackslash{}/index\textbackslash{}\textbackslash{}.php\textbackslash{}\textbackslash{}?pid='}
 fileid <- \hlfunctioncall{sapply}(indexPres, 
                  \hlfunctioncall{function}(x)\{\hlfunctioncall{gsub}(patUrl3,\hlstring{""},x)\},USE.NAMES= FALSE)
 \hlcomment{# Download all files and convert to unix}
 \hlfunctioncall{sapply}(1:\hlfunctioncall{length}(fileid),
        \hlfunctioncall{function}(i)\{
        \hlfunctioncall{system}(\hlfunctioncall{paste}(\hlstring{"wget -q -O \hlstring{'"},fileid[i],\hlstring{".html'} \hlstring{'"},indexPres[i],\hlstring{"'}"},sep=\hlstring{""}));
        \hlfunctioncall{system}(\hlfunctioncall{paste}(\hlstring{"fromdos "},fileid[i],\hlstring{".html"},sep=\hlstring{""}))\})
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(b)}

For each speech, I use pattern matching to extract the body of the speech while retaining 
the name of the president and the year of the speech. The function is applied with vector
operations using \textit{sapply()}.

For the \textit{speechVec}, text pre-processing is done by 
\begin{enumerate}
\item
Replacing HTML line-end with UNIX ones 
\item
Removing all the HTML format operators
\item
Modifying all the HTML special characters to similar UTF-8 ones
\end{enumerate}

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Import all *.html lines}
ff <- \hlfunctioncall{sapply}(fileid, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{readLines}(\hlfunctioncall{paste}(x, \hlstring{".html"}, sep = \hlstring{""}), warn = FALSE)
\})
\hlcomment{# Get the president name}
patName <- \hlstring{"^<title>(.*?)<\textbackslash{}\textbackslash{}/title>"}
namePres <- ff[\hlfunctioncall{grep}(patName, ff, perl = TRUE)]
namePres <- \hlfunctioncall{sapply}(namePres, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patName, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
\}, USE.NAMES = FALSE)
namePres <- \hlfunctioncall{sapply}(namePres, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{":"}))[1])
\}, USE.NAMES = FALSE)
\hlcomment{# Get the talk date}
patDate <- \hlstring{"^.*<span class=\textbackslash{}\textbackslash{}\textbackslash{}"}docdate\textbackslash{}\textbackslash{}\textbackslash{}\hlstring{">(.*?)<\textbackslash{}\textbackslash{}/span>.*$"}
dateTalk <- ff[\hlfunctioncall{grep}(patDate, ff, perl = TRUE)]
dateTalk <- \hlfunctioncall{sapply}(dateTalk, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patDate, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
\}, USE.NAMES = FALSE)
dateTalk <- \hlfunctioncall{sapply}(dateTalk, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"^.*\textbackslash{}\textbackslash{}s"}, \hlstring{""}, x)
\}, USE.NAMES = FALSE)
\hlcomment{# Get the speech content text and prune for nice-format print}
patText <- \hlstring{"^.*<span class=\textbackslash{}\textbackslash{}\textbackslash{}"}displaytext\textbackslash{}\textbackslash{}\textbackslash{}\hlstring{">(.*?)<\textbackslash{}\textbackslash{}/span>.*$"}
speechVec <- ff[\hlfunctioncall{grep}(patText, ff, perl = TRUE)]
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(patText, \hlstring{"\textbackslash{}\textbackslash{}1<p>"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# grab speech text}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"(<p.*?>|<\textbackslash{}\textbackslash{}/p>|<br>)"}, \hlstring{"\textbackslash{}n"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# for line ending}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{gsub}(\hlstring{"<.*?>"}, \hlstring{""}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# remove all html format}
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{"&mdash;"}, \hlstring{" -- "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&nbsp;"}, \hlstring{"  "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&lsquo;"}, \hlstring{" ' "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&#8226;"}, \hlstring{" \textbackslash{}\textbackslash{}. "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&lt;"}, \hlstring{" < "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&deg;"}, \hlstring{" degree "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&pound;"}, \hlstring{" pound "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&fra.*?;"}, \hlstring{" 1/2 "}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&O.*?;"}, \hlstring{"O"}, x)
    x <- \hlfunctioncall{gsub}(\hlstring{"&e.*?;"}, \hlstring{"e"}, x)
\}, USE.NAMES = FALSE)  \hlcomment{# html special char}
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(c)}

Each speech is stored as a single character vector with all non-text stripped out. The encoding is converted from
WINDOWS-1251 to UTF-8.
Meanwhile, the information about the tags of "Laughter" and "Applause" and the number of times it was used
are kept as a record for each speech. The \textit{speechVec[i]} will be printed out in a nicely-formatted manner. 

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Remove audience response \hlfunctioncall{tags} (laughter & applause)}
patLau <- \hlstring{"\textbackslash{}\textbackslash{}[.*?(Laughter|laughter).*?\textbackslash{}\textbackslash{}]"}
patApp <- \hlstring{"\textbackslash{}\textbackslash{}[.*?(Applause|applause).*?\textbackslash{}\textbackslash{}]"}
getlauNum <- \hlfunctioncall{function}(x) \{
    \hlfunctioncall{if} (\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patLau, x, perl = TRUE)[[1]]) == 1 && \hlfunctioncall{gregexpr}(patLau, 
        x, perl = TRUE)[[1]] == -1) \{
        \hlfunctioncall{return}(0)
    \} else \{
        \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patLau, x, perl = TRUE)[[1]]))
    \}
\}  \hlcomment{# get the number of [laughter]}
getappNum <- \hlfunctioncall{function}(x) \{
    \hlfunctioncall{if} (\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patApp, x, perl = TRUE)[[1]]) == 1 && \hlfunctioncall{gregexpr}(patApp, 
        x, perl = TRUE)[[1]] == -1) \{
        \hlfunctioncall{return}(0)
    \} else \{
        \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(patApp, x, perl = TRUE)[[1]]))
    \}
\}  \hlcomment{# get the number of [applause]}
lauNum <- \hlfunctioncall{sapply}(speechVec, getlauNum, USE.NAMES = FALSE)
appNum <- \hlfunctioncall{sapply}(speechVec, getappNum, USE.NAMES = FALSE)
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{iconv}(x, from = \hlstring{"WINDOWS-1251"}, to = \hlstring{"UTF-8"}, sub = \hlstring{" "})
\})
speechVec <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(patLau, \hlstring{""}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(patApp, \hlstring{""}, x, perl = TRUE)
\})
\hlcomment{# remove all the non-verbal tags from the speech text}
\hlfunctioncall{names}(speechVec) <- NULL  \hlcomment{# clean the speechVec \hlfunctioncall{name} (otherwise, long and messy)}
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(d)}

The collection of speeches is stored in a clean fashion of list elements. The \textit{i}th entries of all the elements
in \textit{listSpeech} give information about the \textit{i}th speech. 
This is easy later for plotting variables changes over time.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
listSpeech <- \hlfunctioncall{list}()
listSpeech$id <- fileid
listSpeech$name <- namePres
listSpeech$date <- \hlfunctioncall{as.integer}(dateTalk)  \hlcomment{# conversion for plotting, sorting}
listSpeech$numLaughter <- lauNum
listSpeech$numApplause <- appNum
listSpeech$speech <- speechVec
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(e) (f)}

Words and sentences are extracted from each speech, and are stored as individual elements of a (rather long)
character vector. Counts are also done on both words and sentences.

\newpage
\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
\hlcomment{# Speech analysis Grab words from the speech by replacing all non-word}
\hlcomment{# char with space and split}
getWords <- \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{"'"}, \hlstring{""}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(\hlstring{"\textbackslash{}\textbackslash{}W+"}, \hlstring{" "}, x, perl = TRUE)
    xs <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{"[ ]+"}, perl = TRUE))
    \hlfunctioncall{return}(xs[xs != \hlstring{""}])
\}
\hlcomment{# Grab sentences from the speech by spliting with ending chars like [.!?]}
getSents <- \hlfunctioncall{function}(x) \{
    x <- \hlfunctioncall{gsub}(\hlstring{" (Mr|Ms|Mrs|Dr|St|Sr|Jr)\textbackslash{}\textbackslash{}."}, \hlstring{"\textbackslash{}\textbackslash{}1"}, x, perl = TRUE)
    x <- \hlfunctioncall{gsub}(\hlstring{"[\textbackslash{}\textbackslash{}.!\textbackslash{}\textbackslash{}?][ \textbackslash{}t]+"}, \hlstring{"\textbackslash{}n"}, x, perl = TRUE)
    xs <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(x, \hlstring{"\textbackslash{}n"}, perl = TRUE))
    \hlfunctioncall{return}(xs[xs != \hlstring{""}])
\}
listSpeech$wc <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{getWords}(x)))
\}, USE.NAMES = FALSE)  \hlcomment{# word count}
listSpeech$sc <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{getSents}(x)))
\}, USE.NAMES = FALSE)  \hlcomment{# sentence count}
listSpeech$wMean <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{mean}(\hlfunctioncall{nchar}(\hlfunctioncall{getWords}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{#avg word length}
listSpeech$wSD <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{sd}(\hlfunctioncall{nchar}(\hlfunctioncall{getWords}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# word length sd}
listSpeech$sMean <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{mean}(\hlfunctioncall{nchar}(\hlfunctioncall{getSents}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# avg sentence length}
listSpeech$sSD <- \hlfunctioncall{sapply}(speechVec, \hlfunctioncall{function}(x) \{
    \hlfunctioncall{return}(\hlfunctioncall{sd}(\hlfunctioncall{nchar}(\hlfunctioncall{getSents}(x))))
\}, USE.NAMES = FALSE)  \hlcomment{# sentence length sd}
\end{alltt}
\end{kframe}
\end{knitrout}




\subsection*{(g) (h)}

We now start to extract some features of interest from the speeches to analyze how the speeches have
changed over time. The result of all this is a list with each element containing the information
about a speech: the speech as a single string, the vector of sentences, the vector of words
and the additional quantification of variables about the speech from (g) as well as
the non-verbal variables from (c).

\begin{enumerate}
\item
Length in words and sentences \textit{wc,sc}
\item
Average and SD of word and sentence lengths \textit{wMean,wSD,sMean,sSD}
\item
Number of quotations in each speech, mean length (in words), and SD of length (in words) of the 
quotations in each speech \textit{quoNum,quoMean,quoSD}
\item
The most common meaningful words, where non-meaningful words are pre-defined \textit{cmw}
\item
Counts of the following words or word stems: 
\scriptsize
\begin{description}
\item[I, we]
\item[America{,n}]
\item[democra{cy,tic}]
\item[republic]
\item[Democrat{,ic}]
\item[Republican]
\item[free{,dom}]
\item[war]
\item[God] -- not including God bless
\item[God Bless]
\item[{Jesus, Christ, Christian}]
\item[Woman] -- I think would be interesting
\end{description}
\end{enumerate}
\normalsize

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\begin{alltt}
tmpList <- \hlfunctioncall{matrix}(\hlfunctioncall{rep}(0, 226 * 15), nrow = 226, ncol = 15)
\hlcomment{## Speech list with element-wise analysis}
speechList <- \hlfunctioncall{list}()  \hlcomment{#empty list}
\hlcomment{# Get the non-meaningful words file}
\hlfunctioncall{system}(\hlstring{"wget -O \hlstring{'cmw.txt'} \hlstring{'http://www.textfixer.com/resources/common-english-words.txt'}"})
commonWords <- \hlfunctioncall{readLines}(\hlstring{"cmw.txt"}, warn = FALSE)
commonWords <- \hlfunctioncall{unlist}(\hlfunctioncall{strsplit}(commonWords, \hlstring{","}, perl = TRUE))
\hlcomment{# Element-wise analysis on each speech}
\hlfunctioncall{for} (i in 1:\hlfunctioncall{length}(fileid)) \{
    ss <- \hlfunctioncall{list}()  \hlcomment{#empty list element}
    \hlcomment{# Global attributes: from results \hlfunctioncall{before} (reproduce for better storage)}
    ss$id <- fileid[i]
    ss$name <- namePres[i]
    ss$date <- \hlfunctioncall{as.integer}(dateTalk[i])
    ss$numLaughter <- lauNum[i]
    ss$numApplause <- appNum[i]
    ss$speech <- speechVec[i]
    \hlcomment{# Indiv attributes: get from within each speech}
    talkWords <- \hlfunctioncall{getWords}(speechVec[i])
    talkSents <- \hlfunctioncall{getSents}(speechVec[i])
    ss$words <- talkWords  \hlcomment{# words vector}
    ss$sents <- talkSents  \hlcomment{# sentence vector}
    ss$wc <- \hlfunctioncall{length}(talkWords)  \hlcomment{# word count}
    ss$sc <- \hlfunctioncall{length}(talkSents)  \hlcomment{# sentence count}
    ss$wMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(talkWords))  \hlcomment{# avg word length}
    ss$wSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(talkWords))  \hlcomment{# word length sd}
    ss$sMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(talkSents))  \hlcomment{# avg sentence length}
    ss$sSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(talkSents))  \hlcomment{# sentence length sd; ss[14]}
    patQuo <- \hlstring{"\textbackslash{}"}(.*?)\textbackslash{}\hlstring{""}  # quotation pattern
    quo <- talkSents[\hlfunctioncall{grep}(patQuo, talkSents, perl = TRUE)]
    \hlfunctioncall{if} (\hlfunctioncall{length}(quo) != 0) \{
        \hlcomment{# get quotation attributes}
        quo <- \hlfunctioncall{sapply}(quo, \hlfunctioncall{function}(x) \{
            \hlfunctioncall{gsub}(patQuo, \hlstring{"\textbackslash{}\textbackslash{}1"}, x)
        \}, USE.NAMES = FALSE)
        ss$quoNum <- \hlfunctioncall{length}(quo)
        ss$quoMean <- \hlfunctioncall{mean}(\hlfunctioncall{nchar}(quo))
        ss$quoSD <- \hlfunctioncall{sd}(\hlfunctioncall{nchar}(quo))
    \} else \{
        ss$quoNum <- 0
        ss$quoMean <- 0
        ss$quoSD <- 0
    \}  \hlcomment{#ss[17]}
    
    cmw <- \hlfunctioncall{sort}(\hlfunctioncall{table}(talkWords), decreasing = TRUE)
    cmw <- cmw[\hlfunctioncall{which}(!(\hlfunctioncall{names}(cmw) %in% commonWords))]  \hlcomment{# get meaningful words}
    ss$cmw <- cmw[cmw >= 10]  \hlcomment{#arbitrary cut-off for display}
    ss$strIwe <- cmw[\hlfunctioncall{grep}(\hlstring{"^(I|[Ww]e)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'I|We'}; ss[19]
    ss$strAme <- cmw[\hlfunctioncall{grep}(\hlstring{"[Aa]\hlfunctioncall{merica}(|n)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'America'}
    ss$strDem <- cmw[\hlfunctioncall{grep}(\hlstring{"[Dd]\hlfunctioncall{emocra}(cy|tic)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'democratic'}
    ss$strRep <- cmw[\hlfunctioncall{grep}(\hlstring{"[Rr]\hlfunctioncall{epublic}(|n)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'republican'}
    ss$strFree <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ff]\hlfunctioncall{ree}(|dom)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'free'}
    ss$strWar <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ww]\hlfunctioncall{ar}(|s)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'war'}
    ss$strGod <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Gg]\hlfunctioncall{od}(|s)$"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'God'}
    ss$strChr <- cmw[\hlfunctioncall{grep}(\hlstring{"(Jesus|Christ|Christian)"}, \hlfunctioncall{names}(cmw))]  #string \hlstring{'Chirst|Jesus'}
    ss$strWoman <- cmw[\hlfunctioncall{grep}(\hlstring{"^[Ww]om[ae]n$"}, \hlfunctioncall{names}(cmw))]  #Mystring \hlstring{'Woman'}; ss[27]
    ssGodBless <- talkSents[\hlfunctioncall{grep}(\hlstring{"[Gg]od [Bb]less"}, talkSents, perl = TRUE)]
    \hlfunctioncall{if} (\hlfunctioncall{length}(ssGodBless) != 0) \{
        \hlcomment{#string \hlstring{'God Bless'} from sentences}
        ss$strGodBless <- \hlfunctioncall{sapply}(ssGodBless, \hlfunctioncall{function}(x) \{
            \hlfunctioncall{return}(\hlfunctioncall{length}(\hlfunctioncall{gregexpr}(\hlstring{"[Gg]od [Bb]less"}, x, perl = TRUE)[[1]]))
        \}, USE.NAMES = FALSE)
    \} else \{
        ss$strGodBless <- 0
    \}
    \hlcomment{# add to speechList and listSpeech}
    speechList[[i]] <- ss
    tmpList[i, 1:3] <- \hlfunctioncall{unlist}(ss[15:17])  \hlcomment{#quo attr}
    tmpList[i, 4:13] <- \hlfunctioncall{sapply}(ss[19:28], sum)  \hlcomment{#cmw related attr}
\}
\hlcomment{# prepare for plotting, store as listSpeech elements}
listSpeech$quoNum <- tmpList[, 1]
listSpeech$quoMean <- tmpList[, 2]
listSpeech$quoSD <- tmpList[, 3]
listSpeech$strIwe <- tmpList[, 4]
listSpeech$strAme <- tmpList[, 5]
listSpeech$strDem <- tmpList[, 6]
listSpeech$strRep <- tmpList[, 7]
listSpeech$strFree <- tmpList[, 8]
listSpeech$strWar <- tmpList[, 9]
listSpeech$strGod <- tmpList[, 10]
listSpeech$strChr <- tmpList[, 11]
listSpeech$strWoman <- tmpList[, 12]
listSpeech$strGodBless <- tmpList[, 13]
\end{alltt}
\end{kframe}
\end{knitrout}



\subsection*{(i) (j)}

Some basic plots that show how the variables have changed over time are given below.





\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig} 

}


\end{knitrout}


We can see that the word counts of the speeches are higher prior to 1920s than the modern ages.
So does the avg word length and word length sd. The presidents nowadays seem to like brevity.


Similar plots for sentence counts and quotation counts are given below. The similar trends stand.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig21} 

}



{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig22} 

}


\end{knitrout}


In recent years, with full records of non-verbal attributes, we can see that [Laughter] and [Applause] counts
have some positive correlation. The speeches receive more responses from the audience around 2000 than other years.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-fig3} 

}


\end{knitrout}


And for presidents since Franklin Roosevelt in 1932, comparison between Republican presidents 
(Eisenhower, Nixon, Ford, Reagan, G. Bush, G.W. Bush) and Democratic presidents 
(Roosevelt, Truman, Kennedy, Johnson, Carter, Clinton, Obama) are also given below in the box-plot comparison.



\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-figRD} 

}


\end{knitrout}


\newpage
Some additional research with plotting that illustrates how the speeches have changed over time are shown below.
The different keywords have evolved over time, with peak in WAR during wartime and GOD-rich in recent years.


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex1} 

}


\end{knitrout}


The comparison between Reps and Dems could be more interesting with the strings REPUBLICAN and DEMOCRATIC.
It seems that the Dems are more focused on their persuit while Reps are impartial to both words.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex2} 

}


\end{knitrout}



Some additional variables that quantify speech in interesting ways are produced. The number of digits shown within the
speech is a good indicator whether the president speaks more quantatively, or vice versa, more qualitatively.

\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}

{\centering \includegraphics[width=\maxwidth]{figure/latex-PS23-ex3} 

}


\end{knitrout}




\end{document}
